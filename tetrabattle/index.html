<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Tetra Battle</title>
		<link rel="icon" href="assets/favicon.png">
		<link rel="preload" href="AzonixRegular.woff2" as="font" type="font/woff2" crossorigin>
		<style>
			@font-face {
				font-family: 'Azonix';
				src: url('assets/AzonixRegular.woff2') format('woff2'),
					url('assets/AzonixRegular.woff') format('woff');
				font-weight: normal;
				font-style: normal;
				font-display: swap;
			}

			* {
				color: white;
				text-align: center;
				font-family: "Azonix";
			}

			body {
				background-image: url("assets/background.png");
				background-size: 100vh;
				margin: 0;
				padding: 0;
			}

			canvas {
				position: absolute;
				margin: auto;
				left: 0;
				right: 0;
				top: 0;
				bottom: 0;
			}

			h1 {
				font-size: 100px;
			}

			button {
				background: black;
				font-size: 30px;
				width: 250px;
				height: 60px;
				margin: 2px 30px;
				transition: 0.1s;
			}

			.join:hover, button:hover {
				background-color: #111111;
				transition: 0.1s;
			}

			.join {
				background: black;
				width: 150px;
				height: 30px;
				padding: 0;
				font-size: 25px;
			}

			.bevel {
				border: 2px solid;
				border-image: url("assets/border.svg") 33%;
			}

			#menu {
				margin: 0;
				position: absolute;
				left: 50%;
				top: 25%;
				transform: translateX(-50%);
			}
		</style>
		<script src="https://unpkg.com/peerjs@1.4.5/dist/peerjs.min.js"></script>
	</head>
	<body>
		<div id="menu">
			<h1>tetra battle</h1><br>
			<div>
				<button id="host-button" class="bevel" onclick="hostButtonOnClick()">host</button>
				<button id="join-button" class="bevel" onclick="joinButtonOnClick()">join</button>
			</div>
			<h2 id="host-id" hidden></h2>
			<div id="join-id" hidden>
				<br><input type="text" id="join-code" maxlength="4" class="bevel join">
				<input type="button" value="go" id="join-submit" maxlength="4" class="bevel join" style="width: 75px;">
			</div>
		</div>
		<canvas id="canvas" hidden></canvas>
		<script>
			let deltaTime = 0;
			let lastUpdate = Date.now(); // For deltaTime
			let canvas = document.getElementById("canvas");
			let ctx = canvas.getContext("2d");

			function hostButtonOnClick() {
				document.getElementById("host-id").hidden = false;
				document.getElementById("join-id").hidden = true;
			}

			function joinButtonOnClick() {
				document.getElementById("join-id").hidden = false;
				document.getElementById("host-id").hidden = true;
			}

			(() => { // Scope functions and variables to prevent it from being modified on the brower console
			let gameStarted = false;
			let gameOver = true;
			let win;

			// PeerJS
			const peerId = Math.floor(Math.random() * 8999 + 1000);
			const peer = new Peer(peerId);
			let peerData;
			let conn;
			let hasChanged = false;
			let peerDataTick = Date.now(); // We will close the connection after 5 seconds of no data in case the person closed out of the tab
			document.getElementById("host-id").innerHTML = "code: " + peerId;

			function sendBoardData(garbageToSend = 0) {
				conn.send({
					grid: grid,
					next: nextBlocks,
					hold: currentHoldBlock,
					canHold: canHold,
					garbage: garbage,
					garbageToSend: garbageToSend,
					gameOver: gameOver,
					currentBlock: currentBlock.id
				});
			}

			function quit() {
				document.getElementById("menu").hidden = false;
				document.getElementById("canvas").hidden = true;
				gameStarted = false;
				gameOver = true;
				win = null;
				conn = null;
				peerData = null;
				grid = new Array(40); for (let x = 0; x < grid.length; x++) {grid[x] = new Array(10);}
				currentHoldBlock = undefined;
				canHold = true;
				canHoldAlphaLerp = 0.25;
				garbage = {};
				bag = [...Array(7).keys()];
				nextBlocks = [pickRandom(), pickRandom(), pickRandom(), pickRandom(), pickRandom()];
				currentBlock = new Block(pickNextBlock());
				currentBlock.set();
				fallInterval = 1000;
			}

			// Host the game
			peer.on("connection", (c) => {
				if (conn && conn.open) {
					c.on("open", () => {c.close();});
					return;
				}

				conn = c;
				ready();
			});

			peer.on("disconnected", () => {quit();});
			peer.on("close", () => {quit();});
			peer.on("error", err => {console.log(err);});

			document.getElementById("join-submit").addEventListener("click", () => {
				const joinCode = document.getElementById("join-code").value;
				if (conn) {conn.close();} // Close old connection
				conn = peer.connect(joinCode, {reliable: true});
				conn.on("open", () => {ready();});
			});

			function ready() {
				peerDataTick = Date.now();
				document.getElementById("menu").hidden = true;
				document.getElementById("canvas").hidden = false;
				gameStarted = true;
				gameOver = false;
				setTimeout(() => {sendBoardData();}, 100)

				conn.on("data", data => {
					peerDataTick = Date.now();
					peerData = data;
					if (peerData.garbageToSend > 0) {garbage.push(peerData.garbageToSend);}
					if (!peerData.canHold) {canHoldAlphaLerp2 = 0.25;}
					if (peerData.gameOver) {
						win = true;
						gameOver = true;
						setTimeout(() => {quit()}, 5000);
					}
				});

				conn.on("close", () => {quit();});
			}

			// Update canvas size
			canvas.width = 3000;
			canvas.height = 1500;
			updateWindow();
			window.onresize = updateWindow;

			function updateWindow() {
				if (window.innerWidth / window.innerHeight < canvas.width / canvas.height) {
					canvas.style.width = "100%";
					canvas.style.height = null;
					max = canvas.style.width;
				} else {
					canvas.style.width = null;
					canvas.style.height = "100%";
					max = canvas.style.height;
				}
			}

			function lerp(a, b, t) {return a + (b - a) * t;}
			function clamp(n, min, max) {return Math.max(Math.min(n, max), min);}

			class Vector2 {
				constructor(x = 0, y = 0) {
					this.x = x;
					this.y = y;
				}

				copy() {
					return new Vector2(this.x, this.y);
				}

				add(vec) {
					this.x += vec.x;
					this.y += vec.y;
					return this;
				}

				subtract(vec) {
					this.x -= vec.x;
					this.y -= vec.y;
					return this;
				}

				multiply(vec) {
					this.x *= vec.x;
					this.y *= vec.y;
					return this;
				}
			}
			
			const blocks = [
				[ // I
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(2, 0)],
					[new Vector2(1, 1), new Vector2(1, 0), new Vector2(1, -1), new Vector2(1, -2)],
					[new Vector2(-1, -1), new Vector2(0, -1), new Vector2(1, -1), new Vector2(2, -1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(0, -2)]
				],
				[ // J
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(-1, 1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(1, 1)],
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(1, -1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(-1, -1)]
				],
				[ // L
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(1, 1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(1, -1)],
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(-1, -1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(-1, 1)]
				],
				[ // O
					[new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1), new Vector2(1, 0)],
					[new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1), new Vector2(1, 0)],
					[new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1), new Vector2(1, 0)],
					[new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1), new Vector2(1, 0)]
				],
				[ // S
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(0, 1), new Vector2(1, 1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(1, 0), new Vector2(1, -1)],
					[new Vector2(-1, -1), new Vector2(0, -1), new Vector2(0, 0), new Vector2(1, 0)],
					[new Vector2(-1, 1), new Vector2(-1, 0), new Vector2(0, 0), new Vector2(0, -1)]
				],
				[ // T
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(1, 0)],
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, -1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(0, -1), new Vector2(-1, 0)]
				],
				[ // Z
					[new Vector2(-1, 1), new Vector2(0, 1), new Vector2(0, 0), new Vector2(1, 0)],
					[new Vector2(1, 1), new Vector2(1, 0), new Vector2(0, 0), new Vector2(0, -1)],
					[new Vector2(-1, 0), new Vector2(0, 0), new Vector2(0, -1), new Vector2(1, -1)],
					[new Vector2(0, 1), new Vector2(0, 0), new Vector2(-1, 0), new Vector2(-1, -1)]
				],
			];

			const wallKick = {
				standard: [
					{cw: [new Vector2(), new Vector2(-1), new Vector2(-1, 1), new Vector2(0, -2), new Vector2(-1, -2)],	// 0 -> 1
					ccw: [new Vector2(), new Vector2(1), new Vector2(1, -1), new Vector2(0, 2), new Vector2(1, 2)]},	// 1 -> 0
					{cw: [new Vector2(), new Vector2(1), new Vector2(1, -1), new Vector2(0, 2), new Vector2(1, 2)],		// 1 -> 2
					ccw: [new Vector2(), new Vector2(-1), new Vector2(-1, 1), new Vector2(0, -2), new Vector2(-1, -2)]},// 2 -> 1
					{cw: [new Vector2(), new Vector2(1), new Vector2(1, 1), new Vector2(0, -2), new Vector2(1, -2)],	// 2 -> 3
					ccw: [new Vector2(), new Vector2(-1), new Vector2(-1, -1), new Vector2(0, 2), new Vector2(-1, 2)]},	// 3 -> 2
					{cw: [new Vector2(), new Vector2(-1), new Vector2(-1, -1), new Vector2(0, 2), new Vector2(-1, 2)],	// 3 -> 0
					ccw: [new Vector2(), new Vector2(1), new Vector2(1, 1), new Vector2(0, -2), new Vector2(1, -2)]}	// 0 -> 3
				],
				I: [
					{cw: [new Vector2(), new Vector2(-2), new Vector2(1), new Vector2(-2, -1), new Vector2(1, 2)],
					ccw: [new Vector2(), new Vector2(2), new Vector2(-1), new Vector2(2, 1), new Vector2(-1, -2)]},
					{cw: [new Vector2(), new Vector2(-1), new Vector2(2), new Vector2(-1, 2), new Vector2(2, -1)],
					ccw: [new Vector2(), new Vector2(1), new Vector2(-2), new Vector2(1, -2), new Vector2(-2, 1)]},
					{cw: [new Vector2(), new Vector2(2), new Vector2(-1), new Vector2(2, 1), new Vector2(-1, -2)],
					ccw: [new Vector2(), new Vector2(-2), new Vector2(1), new Vector2(-2, -1), new Vector2(1, 2)]},
					{cw: [new Vector2(), new Vector2(1), new Vector2(-2), new Vector2(1, -2), new Vector2(-2, 1)],
					ccw: [new Vector2(), new Vector2(-1), new Vector2(2), new Vector2(-1, 2), new Vector2(2, -1)]}
				]
			}

			/*
			Block Ids
			undefined = None
			0 = I
			1 = J
			2 = L
			3 = O
			4 = S
			5 = T
			6 = Z
			7 = Garbage
			8 = Current
			9 = Ghost
			*/

			class Block {
				constructor(id) {
					this.id = id;
					this.pos = new Vector2(4, 20);
					this.rotation = 0;
				}

				empty() {
					for (let y = 0; y < grid.length; y++) {
						for (let x = 0; x < grid[y].length; x++) {
							if (grid[y][x] == 8) {grid[y][x] = undefined;}
						}
					}
				}

				set() {
					this.empty();
					let cells = this.getCells();
					for (let i = 0; i < cells.length; i++) {
						let pos = cells[i];
						grid[pos.y][pos.x] = 8;
					}
				}

				getCells() {
					const cells = [];
					for (let i = 0; i < blocks[this.id][this.rotation].length; i++) {cells.push(this.pos.copy().add(blocks[this.id][this.rotation][i]));}
					return cells;
				}

				isValid(offset = new Vector2()) {
					let cells = this.getCells();
					for (let i = 0; i < cells.length; i++) {
						let pos = cells[i].copy().add(offset);
						if (pos.x < 0 || pos.x >= 10 || pos.y < 0 || pos.y >= 40 || grid[pos.y][pos.x] != undefined && grid[pos.y][pos.x] < 8) {return false;}
					}
					return true;
				}

				isGrounded() {
					return !this.isValid(new Vector2(0, -1));
				}

				move(offset) {
					if (this.isValid(offset)) {
						this.pos.add(offset);
						this.set();
						return true;
					}
					return false;
				}

				rotateCW() {
					let wallKickData = this.id == 0 ? wallKick.I[this.rotation].cw : wallKick.standard[this.rotation].cw;
					this.rotation = (this.rotation + 1) % 4;
					for (let i = 0; i < wallKickData.length; i++) {
						if (this.move(wallKickData[i])) {return true;}
					}
					this.rotation = (this.rotation + 3) % 4;
					return false;
				}

				rotateCCW() {
					this.rotation = (this.rotation + 3) % 4;
					let wallKickData = this.id == 0 ? wallKick.I[this.rotation].ccw : wallKick.standard[this.rotation].ccw;
					for (let i = 0; i < wallKickData.length; i++) {
						if (this.move(wallKickData[i])) {return true;}
					}
					this.rotation = (this.rotation + 1) % 4;
					return false;
				}
			}

			function setLockAction(action) {
				if (action) {
					hasChanged = true;

					if (currentBlock.isGrounded()) {
						lockEnabled = true;
						lockTick = Date.now();
						lockActions++;
					} else {
						lockEnabled = false;
					}
				}
			}

			function addGarbageLines() {
				if (garbage.length == 0) {return;}
				let empty = Math.floor(Math.random() * 9);
				
				for (let y = grid.length - 1; y >= garbage[0]; y--) {
					for (let x = 0; x < grid[y].length; x++) {
						grid[y][x] = grid[y - garbage[0]][x];
						grid[y - garbage[0]][x] = undefined;
					}
				}

				for (let y = 0; y < garbage[0]; y++) {
					for (let x = 0; x < grid[y].length; x++) {
						grid[y][x] = x == empty ? undefined : 7;
					}
				}

				garbage.splice(0, 1);
			}
			
			function clearGarbage(amount) {
				for (let i = 0; i < garbage.length; i++) {
					if (garbage[i] > amount) {
						garbage[i] -= amount;
						amount = 0;
						return;
					} else {
						amount -= garbage[i];
						garbage.splice(i, 1);
					}
				}
			}

			function clearFullRows() {
				let cleared = 0;

				for (let y = 0; y < grid.length; y++) {
					let isRowFull = true;

					for (let x = 0; x < grid[y].length; x++) {
						if (grid[y][x] == undefined) {
							isRowFull = false;
							break;
						}
					}

					if (isRowFull) { // Clear row
						for (let x = 0; x < grid[y].length; x++) {
							grid[y][x] = undefined;
						}
						cleared++;
					} else if (cleared > 0) { // Move row down
						for (let x = 0; x < grid[y].length; x++) {
							grid[y - cleared][x] = grid[y][x];
							grid[y][x] = undefined;
						}
					}
				}

				if (cleared == 0) {addGarbageLines()} else {clearGarbage(cleared); return cleared;}
			}

			function lock() {
				lockEnabled = false;
				lockActions = 0;

				currentBlock.empty();
				let cells = currentBlock.getCells();
				
				for (let i = 0; i < cells.length; i++) {
					let pos = cells[i];
					grid[pos.y][pos.x] = currentBlock.id;

					if (cells[i].y > 21) {
						gameOver = true;
						win = false;
						setTimeout(() => {quit()}, 5000);
					}
				}

				let cleared = clearFullRows();
				currentBlock = new Block(pickNextBlock());

				if (!currentBlock.isValid()) {
					gameOver = true;
					win = false;
					setTimeout(() => {quit()}, 5000);
					return;
				}

				currentBlock.set();
				canHold = true;
				sendBoardData(cleared);
			}

			
			let bag = [...Array(7).keys()];

			function pickRandom() {
				const index = Math.floor(Math.random() * bag.length);
				const id = bag[index];
				bag.splice(index, 1);
				if (bag.length == 0) {bag = [...Array(7).keys()];}
				return id;
			}

			let nextBlocks = [pickRandom(), pickRandom(), pickRandom(), pickRandom(), pickRandom()];

			function pickNextBlock() {
				let next = nextBlocks[0];
				for (let i = 0; i < nextBlocks.length - 1; i++) {nextBlocks[i] = nextBlocks[i + 1];}
				nextBlocks[nextBlocks.length - 1] = pickRandom();
				return next;
			}

			let currentHoldBlock = undefined;
			let canHold = true;
			let canHoldAlphaLerp = 0.25;
			let canHoldAlphaLerp2 = 0.25;

			function holdBlock() {
				if (canHold) {
					canHold = false;
					canHoldAlphaLerp = 0.25;
					
					if (currentHoldBlock != undefined) { // Block in hold
						let id = currentHoldBlock;
						currentHoldBlock = currentBlock.id;
						currentBlock = new Block(id);
						currentBlock.set();
					} else { // No block in hold
						currentHoldBlock = currentBlock.id;
						currentBlock = new Block(pickNextBlock());
						currentBlock.set();
					}
				}
			}

			const keyCodes = {
				shiftLeft: ["ArrowLeft"],
				shiftRight: ["ArrowRight"],
				softDrop: ["ArrowDown"],
				hardDrop: ["Space"],
				rotateCW: ["ArrowUp", "KeyX"],
				rotateCCW: ["ControlLeft", "KeyZ"],
				hold: ["ShiftLeft", "KeyC"]
			};

			let fallInterval = 1000;
			let fallTick = Date.now();
			const softDropScalar = 20;
			let softDropEnabled = false;

			const shiftDelay = 150;
			const shiftInterval = 30;
			let shiftDelayTick = Date.now();
			let shiftTick = Date.now();
			let shiftDir = 0;

			const lockInterval = 500;
			const lockMaxActions = 15;
			let lockTick = Date.now();
			let lockActions = 0;
			let lockEnabled = false;

			let grid = new Array(40); for (let x = 0; x < grid.length; x++) {grid[x] = new Array(10);}
			let garbage = [];
			let combo = 0;

			const board = new Image(); board.src = "assets/board.png";
			const minoTextures = new Image(); minoTextures.src = "assets/minos.png";

			let currentBlock = new Block(pickNextBlock());
			currentBlock.set();

			function render() {
				// deltaTime
				let now = Date.now();
				deltaTime = (now - lastUpdate) / 1000;
				lastUpdate = now;

				ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

				// Player board
				if (gameStarted) {
					// Grid
					ctx.drawImage(board, canvas.width * 0.15, (canvas.height - board.height) / 2);

					for (let y = 0; y < grid.length; y++) {
						for (let x = 0; x < grid[y].length; x++) {
							if (grid[y][x] < 8) {
								ctx.drawImage(minoTextures,
									grid[y][x] * 45, 0, // Image slice x, y
									45, 45, // Image slice width, height
									canvas.width * 0.15 + 264 + x * 45, (canvas.height - board.height) / 2 + 855 - y * 45, // Canvas x, y
									45, 45 // Canvas width, height
								);
							} else if (grid[y][x] >= 8) { // Current/Ghost block
								if (grid[y][x] == 9) {ctx.globalAlpha = 0.25;} // Make ghost block transparent
								ctx.drawImage(minoTextures,
									currentBlock.id * 45, 0,
									45, 45,
									canvas.width * 0.15 + 264 + x * 45, (canvas.height - board.height) / 2 + 855 - y * 45,
									45, 45
								);
								ctx.globalAlpha = 1;
							}
						}
					}

					// Next blocks
					for (let i = 0; i < nextBlocks.length; i++) {
						for (let j = 0; j < blocks[nextBlocks[j]][0].length; j++) {
							const pos = blocks[nextBlocks[i]][0][j];
							if (nextBlocks[i] == 0) { // I
								ctx.drawImage(minoTextures,
									nextBlocks[i] * 45, 0,
									45, 45,
									canvas.width * 0.15 + 798 + pos.x * 45, (canvas.height - board.height) / 2 + 93 + i * 135 - pos.y * 45,
									45, 45
								);
							} else if (nextBlocks[i] == 3) { // O
								ctx.drawImage(minoTextures,
									nextBlocks[i] * 45, 0,
									45, 45,
									canvas.width * 0.15 + 798 + pos.x * 45, (canvas.height - board.height) / 2 + 116 + i * 135 - pos.y * 45,
									45, 45
								);
							} else { // JLSTZ
								ctx.drawImage(minoTextures,
									nextBlocks[i] * 45, 0,
									45, 45,
									canvas.width * 0.15 + 820 + pos.x * 45, (canvas.height - board.height) / 2 + 116 + i * 135 - pos.y * 45,
									45, 45
								);
							}
						}
					}

					// Hold block
					if (currentHoldBlock != null) {
						for (let i = 0; i < blocks[currentHoldBlock][0].length; i++) {
							const pos = blocks[currentHoldBlock][0][i];
							canHoldAlphaLerp = lerp(canHoldAlphaLerp, canHold ? 1 : 0.25, deltaTime * 2);
							ctx.globalAlpha = canHoldAlphaLerp;

							if (currentHoldBlock == 0) { // I
								ctx.drawImage(minoTextures,
								currentHoldBlock * 45, 0,
									45, 45,
									canvas.width * 0.15 + 71 + pos.x * 45, (canvas.height - board.height) / 2 + 93 - pos.y * 45,
									45, 45
								);
							} else if (currentHoldBlock == 3) { // O
								ctx.drawImage(minoTextures,
								currentHoldBlock * 45, 0,
									45, 45,
									canvas.width * 0.15 + 71 + pos.x * 45, (canvas.height - board.height) / 2 + 116 - pos.y * 45,
									45, 45
								);
							} else { // JLSTZ
								ctx.drawImage(minoTextures,
								currentHoldBlock * 45, 0,
									45, 45,
									canvas.width * 0.15 + 94 + pos.x * 45, (canvas.height - board.height) / 2 + 116 - pos.y * 45,
									45, 45
								);
							}
							ctx.globalAlpha = 1;
						}
					}

					// Garbage
					let totalGarbage = 0;
					for (let i = 0; i < garbage.length; i++) {totalGarbage += garbage[i];}
					ctx.fillStyle = "red";
					ctx.fillRect(
						canvas.width * 0.15 + 245,
						(canvas.height - board.height) / 2 + 899 - totalGarbage * 45,
						14,
						totalGarbage * 45
					);

					// Opponent board
					ctx.drawImage(board, canvas.width * 0.85 - board.width, (canvas.height - board.height) / 2);

					if (peerData) {
						for (let y = 0; y < peerData.grid.length; y++) {
							for (let x = 0; x < peerData.grid[y].length; x++) {
								if (peerData.grid[y][x] == null) {continue;}
								if (peerData.grid[y][x] < 8) {
									ctx.drawImage(minoTextures,
										peerData.grid[y][x] * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 264 + x * 45, (canvas.height - board.height) / 2 + 855 - y * 45,
										45, 45
									);
								} else if (peerData.grid[y][x] >= 8) {
									if (peerData.grid[y][x] == 9) {ctx.globalAlpha = 0.25;}
									ctx.drawImage(minoTextures,
										peerData.currentBlock * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 264 + x * 45, (canvas.height - board.height) / 2 + 855 - y * 45,
										45, 45
									);
									ctx.globalAlpha = 1;
								}
							}
						}

						// Next blocks
						for (let i = 0; i < peerData.next.length; i++) {
							for (let j = 0; j < blocks[peerData.next[j]][0].length; j++) {
								const pos = blocks[peerData.next[i]][0][j];
								if (peerData.next[i] == 0) { // I
									ctx.drawImage(minoTextures,
										peerData.next[i] * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 798 + pos.x * 45, (canvas.height - board.height) / 2 + 93 + i * 135 - pos.y * 45,
										45, 45
									);
								} else if (peerData.next[i] == 3) { // O
									ctx.drawImage(minoTextures,
										peerData.next[i] * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 798 + pos.x * 45, (canvas.height - board.height) / 2 + 116 + i * 135 - pos.y * 45,
										45, 45
									);
								} else { // JLSTZ
									ctx.drawImage(minoTextures,
										peerData.next[i] * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 820 + pos.x * 45, (canvas.height - board.height) / 2 + 116 + i * 135 - pos.y * 45,
										45, 45
									);
								}
							}
						}

						// Hold block
						if (peerData.hold != undefined) {
							for (let i = 0; i < blocks[peerData.hold][0].length; i++) {
								const pos = blocks[peerData.hold][0][i];
								canHoldAlphaLerp2 = lerp(canHoldAlphaLerp2, peerData.canHold ? 1 : 0.25, deltaTime * 2);
								ctx.globalAlpha = canHoldAlphaLerp2;

								if (peerData.hold == 0) { // I
									ctx.drawImage(minoTextures,
										peerData.hold * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 71 + pos.x * 45, (canvas.height - board.height) / 2 + 93 - pos.y * 45,
										45, 45
									);
								} else if (peerData.hold == 3) { // O
									ctx.drawImage(minoTextures,
										peerData.hold * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 71 + pos.x * 45, (canvas.height - board.height) / 2 + 116 - pos.y * 45,
										45, 45
									);
								} else { // JLSTZ
									ctx.drawImage(minoTextures,
										peerData.hold * 45, 0,
										45, 45,
										canvas.width * 0.85 - board.width + 94 + pos.x * 45, (canvas.height - board.height) / 2 + 116 - pos.y * 45,
										45, 45
									);
								}
								ctx.globalAlpha = 1;
							}
						}

						// Garbage
						totalGarbage = 0;
						for (let i = 0; i < peerData.garbage.length; i++) {totalGarbage += peerData.garbage[i];}
						ctx.fillRect(
							canvas.width * 0.85 - board.width + 245,
							(canvas.height - board.height) / 2 + 899 - totalGarbage * 45,
							14,
							totalGarbage * 45
						);
					}

					if (gameOver && win != null) {
						ctx.font = "100px Azonix";
						ctx.textAlign = "center";
						ctx.textBaseline = "middle";
						ctx.fillStyle = win ? "lime" : "red";
						ctx.fillText(win ? "Win" : "Lose", canvas.width / 2, canvas.height / 2);
						ctx.fillStyle = "black";
						ctx.lineWidth = 2;
						ctx.strokeText(win ? "Win" : "Lose", canvas.width / 2, canvas.height / 2);
					}
				}
			}

			function update() {
				if (gameStarted) {
					if (!gameOver) {
						// Drop block
						if (Date.now() - fallTick > (softDropEnabled ? fallInterval / softDropScalar : fallInterval)) {
							fallTick = Date.now();
							currentBlock.move(new Vector2(0, -1));
							hasChanged = true;

							if (currentBlock.isGrounded()) {
								if (!lockEnabled) {
									lockEnabled = true;
									lockTick = Date.now();
								}
							} else {
								lockEnabled = false;
							}
						}

						// Shift block
						if (Date.now() - shiftDelayTick > shiftDelay && Date.now() - shiftTick > shiftInterval && shiftDir != 0) {
							shiftTick = Date.now();
							if (currentBlock.move(new Vector2(shiftDir, 0))) {setLockAction(true);}
						}

						// Ghost block
						for (let y = 0; y < grid.length; y++) {
							for (let x = 0; x < grid[y].length; x++) {
								if (grid[y][x] == 9) {grid[y][x] = undefined;}
							}
						}
						
						let drop = 0;
						for (let i = 0; i < grid.length; i++) {
							if (!currentBlock.isValid(new Vector2(0, -drop))) {
								let cells = currentBlock.getCells();
								for (let j = 0; j < cells.length; j++) {
									let pos = cells[j].copy().add(new Vector2(0, -drop + 1));
									grid[pos.y][pos.x] = grid[pos.y][pos.x] != undefined ? grid[pos.y][pos.x] : 9;
								}
								break;
							} else {drop++}
						}
						
						fallInterval = Math.max(fallInterval - deltaTime, 25)
						if (lockEnabled && (Date.now() - lockTick > lockInterval || lockActions > lockMaxActions)) {lock();} // Lock block
						if (Date.now() - peerDataTick > 5000 && conn) {conn.close();}
					}
				}

				if (hasChanged) {sendBoardData();}
				hasChanged = false;
				render();
			}

			document.addEventListener("keydown", event => {
				if (gameOver) {return;}
				if (keyCodes.shiftLeft.indexOf(event.code) > -1) {
					shiftDelayTick = Date.now();
					shiftTick = Date.now();
					shiftDir = -1;
					if (currentBlock.move(new Vector2(-1, 0))) {setLockAction(true);}
				} else if (keyCodes.shiftRight.indexOf(event.code) > -1) {
					shiftDelayTick = Date.now();
					shiftTick = Date.now();
					shiftDir = 1;
					if (currentBlock.move(new Vector2(1, 0))) {setLockAction(true);}
				} else if (keyCodes.softDrop.indexOf(event.code) > -1) {
					softDropEnabled = true;
				} else if (keyCodes.rotateCW.indexOf(event.code) > -1) {
					setLockAction(currentBlock.rotateCW());
				} else if (keyCodes.rotateCCW.indexOf(event.code) > -1) {
					setLockAction(currentBlock.rotateCCW());
				} else if (keyCodes.hardDrop.indexOf(event.code) > -1) {
					for (let i = 0; i < grid.length; i++) {
						if (!currentBlock.move(new Vector2(0, -1))) {
							lock();
							hasChanged = true;
							break;
						}
					}
				} else if (keyCodes.hold.indexOf(event.code) > -1) {
					holdBlock();
					hasChanged = true;
				}
			});

			document.addEventListener("keyup", event => {
				if (keyCodes.shiftLeft.indexOf(event.code) > -1) {
					shiftDir = shiftDir == -1 ? 0 : 1;
				} else if (keyCodes.shiftRight.indexOf(event.code) > -1) {
					shiftDir = shiftDir == 1 ? 0 : -1;
				} else if (keyCodes.softDrop.indexOf(event.code) > -1) {
					softDropEnabled = false;
				}
			});

			setInterval(update);
		})();
		</script>
	</body>
</html>